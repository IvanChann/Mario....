Recommending reading REQ4 Documentation and UML diagram first

Added BuyItemAction that extends Action and WalletManager

WalletManager has a private constructor to prevent instantiation and has a private attribute of itself which can be 
retrieved by calling getInstance. Thus, it has an association with itself

I chose to add WalletManager instead of adding a private attribute called wallet into player so I don't need
to downcast Actor to Player when using BuyItemAction to check for wallet. Additionally, by logic, having a singleton wallet manager makes sense 
because only the player of the game will need access to the wallet. This also allows for extension of the wallet system
since it also allows other actors to collect coins FOR the player, such as coin collectors, which wouldn't be possible if we
used a wallet attribute for specific actors which requires downcasting.

Added PickupCoinAction that handles picking up coins that instantly add credits to WalletManager

PickupCoinAction has association to Actor and Coin class since they need to be kept as attributes to show the appropriate message in menu.
Also, the execute method needs to know the coin to remove the coin from the map afterwards. 
The value of the coin also needs to be accessible.

Justification for the 0..* multiplicity between Actor and PickUpCoinAction is that an actor can have multiple PickUpCoinActions if 
there are multiple coins in the same location. 

PickupCoinAction has an important dependency with WalletManager since it must call getInstance then add the appropriate 
amount of credits corresponding to the coin's worth.

Initially, I wanted to rename Coin to Valuables and make it abstract, create a PickupValuableAction class, then create a 
Coin class which extends Valuable so that the game can add new valuable items such as Diamonds or Sapphires 
that give some other functionalities too when picked up.
Even though this would follow OCP, I concluded it to be not worth the unnecessary complexity because
it seemed highly unlikely a Mario game would add other instantly consumed currency items with different functionalities. 


Added BuyableItem interface containing method getPrice(). 
Made Super Mushroom and Power Star implement BuyableItem. Created Wrench class that extends Item and implements BuyableItem
Don't have relationship between Item and Super Mushroom/Power Star because it's in REQ4 UML Class diagram

Reason I added a BuyableItem interface is to account for future buyable items that might be added (Open for extension)

Added Toad class that extends Actor and has an association with BuyableItem because he keeps an ArrayList of 
BuyableItems that he can sell by iterating through the array and creating BuyItemActions for each buyable item

BuyItemAction has a dependency with WalletManager and an association with BuyableItem and Actor because it needs to be able to
add the buyable item to the player's inventory after deducting the balance from WalletManager, or if there is not enough credits,
then the item isn't added.

See BuyItemAction sequence diagram

Justification for type-casting in BuyItemAction:
BuyItemAction casts BuyableItem to Item since addItemToInventory only accepts an instance of Item. But the type-casting here
is fine because BuyableItem is guaranteed to be an item, and any buyable item is safe to be added into the player's inventory
unless implemented incorrectly. 
The only ways to avoid this type-cast are to either remove the BuyableItem interface and make BuyItemAction's constructor take an 
instance of Item rather than BuyableItem, or to make BuyableItem an abstract class which extends item, which 
doesn't make much sense because we can have a WeaponItem that is buyable, such as the wrench, which obviously can only extend
from one abstract class.







